# TODO

## `FormValidityObserver`

- [ ] Add docs at some point on why we _don't_ allow structuring form data as nested objects like `React Hook Form`, `Conform`, etc.
  1.  It adds additional overhead to the project to try to support it
  2.  The form data submitted to the server is not going to have this unusual structure anyway if you're using progressive enhancement (unless you want to validate 2 different structures of form data ... which is unnecessarily complicated). Therefore, it's better to just embrace what HTML gives you out of the box. If you're trying to think of how to group your data (e.g., address fields), think about using `names` that help you scope things better. For example, use `address_street`, `address_city`, and the like. Then, on your server, you can determine scoping by `split`ing strings by underscores.
- [ ] Perhaps somewhere we should explain that this is a library built with progressive enhancement in mind ... and that we seek to _embrace_ and _extend_ native HTML/JS features (like Svelte) instead of recreating them in a complex or less efficient fashion. The previous TODO item is an example of this ... We're thinking of progressively enhnaced web apps by default, therefore we're thinking about the server, therefore there's no point in supporting weird nested object data for form fields on the frontend.
  - Even thinking about that ... Perhaps it would be good to get a clear idea of: "What Problem Is Our Library Trying to Solve?" And perhaps we can aim to communicate that clearly for the users of our package.
- [ ] Maybe we should have a "potential pitfalls" or "pro tips" section?
  - [ ] For example, anyone who extends the `FormObserver` should probably use arrow functions for event handlers if they ever want to use `this` ... It will make life much easier.
  - [ ] In a similar vein, should we add a warning that radio buttons must be semantically correct in order for them to participate in field validation? This really shouldn't be an issue; but since this isn't enforced by React (due to state), some people may need to know this. This would basically just mean that radios belonging to the same group would need to share a common `name`.
- [ ] TODO: We're doing something wrong with how we're setting up **ALL** of the `FormObserver` classes that's causing JS (or at least _TS_) to wrongly think that the name for ALL of our classes is `_a`. It seems that, generally speaking, JS/TS can derive the correct name for an anonymous class. But in our case, the `name` won't be derived unless we explicitly supply it to the class declaration (which we can't, given all of the name clashing)... So ... What do we do? We'll figure that out later. Maybe migrating to JS docs will fix this problem too?
- [ ] Should the `ValidationErrors` interface reference the classic form field properties, or the `ValidityState` properties? Using the regular form field properties is great if you're using regular HTML Elements. But it might be a little less intuitive for those using Custom Elements. (There are also downsides to shifting our approach. So this would require some thinking.)
- [ ] Should we require developers to make their `ElementInternals`-owning Web Component the component that receives the field-related ARIA Attributes? Should we allow for something else like a `data-delegate-aria` attribute that says, "Use this other element for ARIA related actions instead"?
- [ ] The `aria-describedby` attribute technically supports multiple IDs at one time. Should we add a `data-describedby` (or `data-errormessage`) attribute for cases like these? We would need to enforce that the `data-errormessage` value is a substring of the `aria-describedby` value in this case (so that the error message is still _accessible_). However, it's hard to say how realistic this scenario would be. Anyone attempting to do this would also have to deal with the fact that the various descriptions would get joined together into a "single unit"... So they'd have to be mindful of the order of their `aria-describedby` ids anyway. This might be worth tackling, but it doesn't seem urgent; so we're delaying it.

### `FormValidityObserver` Optimizations

- [ ] Would it be helpful to have an `optimize` option for `FormValidityObserver` where the developer _promises_ to `register` all fields that they want validated (and `unregister` anything that later shouldn't be validated), so that we can loop over all of the registered field `name`s instead of looping over `form.elements` when `validateFields` is called without an argument?
- [ ] Is there a way that we could call `form.checkValidity()` if **none** of the fields have a registered custom `validate` function? Would that be a meaningful performance boost (if any)? (If we did that, we might also need to add a `capture`d `invalid` event handler to make sure error messages are properly updated if needed.)
  - **Note**: It may be sufficient/appropriate to delegate this to user land. Perhaps we could simply add documentation saying, "For a performance boost, if you don't have any custom `validate` functions, just use `form.checkValidity()`" or something like that. (This, again, is _assuming_ that `form.checkValidity()` yields a significant performance boost over `observer.validateFields()`. We need to test that.) If we go with this approach, we'd probably still need to register `invalid` event handlers. So we need to think about how we'd go about that if we want to go that route.

### `FormValidityObserver` Potential Future Ideas/Features

- [ ] Provide a way for users to specify the value of `aria-invalid` (e.g., `spelling`). Maybe we could do this through the `ValidationErrors` configuration? (**Note: This idea might not even be significant or truly needed.**)
- [ ] Provide a way for users to focus the first field that errored out.
  - We shouldn't need to provide _access_ to the field that errored out, right? The browser just focuses the first field that errors out on its own. Is it sufficient to copy the browser's behavior there? It makes sense considering that it makes the user aware not only of the current erroneous fields, but _all_ erroneous fields that come after. (It also indicates that no preceding fields are erroneous ... provided that the developer didn't do some weird layout shifting with a flexbox or grid.)
- [ ] Provide an easy way for users to scroll to the field that errored out.
  - Should we support a custom scroller function option for people who need more control over how scrolling happens? Or should we just expose some simple, fixed options for how to scroll. Probably both?
- [ ] Perhaps we should dispatch the `invalid` event when validation fails? Just like the browser does? If we're claiming to _enhance_ the browser's functionality, then we don't really want to _take away_ anything that the browser does. Instead, we want to _add_ to it (as effectively, powerfully, and minimalistically as possible).

## TypeScript

- The [`@link`](https://jsdoc.app/tags-inline-link.html) JSDoc annotation is _really_ helpful for referencing internal names (e.g., a method/field belonging to the current class in which the comment is scoped). However, it seems to have some limitations in TypeScript. When an `interface` is used to define a name (e.g., `interface FormValidityObserver { /* ... */ }`) _and_ that same name is used as an anonymous class (e.g., `const FormValidityObserver = class { /* ... */ }`), the internal linking works within the anonymous class, but _it breaks inside the `interface`_. (Of the two, this is probably the better way for things to break.) Is this a bug in TypeScript? Should we open an issue? (... Is `implements` the problem? Would `satisfies` fix it?)
  - Similarly, yet separately (and likely in this same scenario), we see that the physical overriden methods within the `FormValidityObserver` are inheriting the wrong JSDoc (AND they don't show the proper JSDocs when hovering over the method parameters). But the JSDocs for methods _are_ correct when the class is physically used/instantiated. Also potentially a bug? Should we open an issue for this?
  - The end-developer's experience isn't really impacted by these problems... so we'll open these issues in the future.

## Testing

- Consider migrating away from `React Testing Library` in all `@form-observer/core` tests. Keyword: **consider**. It might be more work than it's worth, but it would technically embody the idea that the core package should work with pure JS.
