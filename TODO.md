# TODO

## Documentation

- [ ] In the interest of time, we're probably going to have to do the bare minimum when it comes to the documentation. Make the API clear, give some helpful examples, etc. After we've release the first draft of the project, we can start thinking about how to "perfect" the docs. But for now, don't get too paranoid about the wording.

## `FormValidityObserver`

- [ ] Add docs at some point on why we _don't_ allow structuring form data as nested objects like `React Hook Form`, `Conform`, etc.
  1.  It adds additional overhead to the project to try to support it
  2.  The form data submitted to the server is not going to have this unusual structure anyway if you're using progressive enhancement (unless you want to validate 2 different structures of form data ... which is unnecessarily complicated). Therefore, it's better to just embrace what HTML gives you out of the box. If you're trying to think of how to group your data (e.g., address fields), think about using `names` that help you scope things better. For example, use `address_street`, `address_city`, and the like. Then, on your server, you can determine scoping by `split`ing strings by underscores.
- [ ] Perhaps somewhere we should explain that this is a library built with progressive enhancement in mind ... and that we seek to _embrace_ and _extend_ native HTML/JS features (like Svelte) instead of recreating them in a complex or less efficient fashion. The previous TODO item is an example of this ... We're thinking of progressively enhnaced web apps by default, therefore we're thinking about the server, therefore there's no point in supporting weird nested object data for form fields on the frontend.
  - Even thinking about that ... Perhaps it would be good to get a clear idea of: "What Problem Is Our Library Trying to Solve?" And perhaps we can aim to communicate that clearly for the users of our package.
- [ ] Maybe we should have a "potential pitfalls" or "pro tips" section?
  - [ ] For example, anyone who extends the `FormObserver` should probably use arrow functions for event handlers if they ever want to use `this` ... It will make life much easier.
  - [ ] In a similar vein, should we add a warning that radio buttons must be semantically correct in order for them to participate in field validation? This really shouldn't be an issue; but since this isn't enforced by React (due to state), some people may need to know this. This would basically just mean that radios belonging to the same group would need to share a common `name`.
- [ ] TODO: We're doing something wrong with how we're setting up **ALL** of the `FormObserver` classes that's causing JS (or at least _TS_) to wrongly think that the name for ALL of our classes is `_a`. It seems that, generally speaking, JS/TS can derive the correct name for an anonymous class. But in our case, the `name` won't be derived unless we explicitly supply it to the class declaration (which we can't, given all of the name clashing)... So ... What do we do? We'll figure that out later. Maybe migrating to JS docs will fix this problem too?
- [ ] Should the `ValidationErrors` interface reference the classic form field properties, or the `ValidityState` properties? Using the regular form field properties is great if you're using regular HTML Elements. But it might be a little less intuitive for those using Custom Elements. (There are also downsides to shifting our approach. So this would require some thinking.)
- [ ] Should we require developers to make their `ElementInternals`-owning Web Component the component that receives the field-related ARIA Attributes? Should we allow for something else like a `data-delegate-aria` attribute that says, "Use this other element for ARIA related actions instead"?
- [ ] The `aria-describedby` attribute technically supports multiple IDs at one time. Should we add a `data-describedby` (or `data-errormessage`) attribute for cases like these? We would need to enforce that the `data-errormessage` value is a substring of the `aria-describedby` value in this case (so that the error message is still _accessible_). However, it's hard to say how realistic this scenario would be. Anyone attempting to do this would also have to deal with the fact that the various descriptions would get joined together into a "single unit"... So they'd have to be mindful of the order of their `aria-describedby` ids anyway. This might be worth tackling, but it doesn't seem urgent; so we're delaying it.
- [ ] Up to this point, we've been defining the `FormField` type as any `HTMLElement` that will _naturally_ appear in a [form's list of elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements). However, this definition isn't fully accurate anymore given that we're now trying to be cognizant of Web Components. We need to figure out a new definition that works. There are several possible approaches to this problem... Perhaps we could support a custom `interface` that extends `HTMLElement` and supports/exposes all necessary properties/methods -- including those from `ElementInternals`. But how simple/complex is that? Is this something that we should delegate to userland? We need to think more on this.
- [ ] It's a little bothersome to us that in the `validateFields()` method, `getErrorOwningControl` technically has to be called twice when scrolling an invalid field into view. It's not the end of the world, but it doesn't feel like a clean solution either. This might be another reason to migrate towards checking `field.validity.valid` instead of `field.getAttribute("aria-invalid") === String(true)`. (This would require passing `errorElement.innerText`/`errorElement.textContent` to `setCustomValidity` whenever we use the `renderer` function to render error messages to the DOM.)
- [ ] Where reasonable, support legacy APIs of JS Frameworks -- such as React Class Components.

### `FormValidityObserver` Optimizations

- [ ] Would it be helpful to have an `optimize` option for `FormValidityObserver` where the developer _promises_ to `configure` all fields that they want validated (and `deconfigure` anything that later shouldn't be validated), so that we can loop over all of the configured field `name`s instead of looping over `form.elements` when `validateFields` is called without an argument?
  - **Edit**: We probably won't be doing this because it seems to add additional complexity without much meaningful benefit. This is something that can be done in userland if needed. (And the actual performance gains that users will achieve with this are likely small.) Pushing this off to userland brings a little bit of complexity to the users who would like this functionality, but _most_ of the complexity that would be involved is something that the `FormValidityObserver` cannot simplify for our users anyway; React Hook Form's examples of their [`unregister`](https://react-hook-form.com/docs/useform/unregister) function prove this. At best, we could store the configured fields for our users; but our users would still need to write their own logic for "unconfiguring" form fields (just like with React Hook Form). And since users can easily store (and loop over) the configured fields in a `Map` (or whichever structure they prefer), it doesn't seem practical for the `FormValidityObserver` to take that storage responsibility.
- [ ] Is there a way that we could call `form.checkValidity()` if **none** of the fields have a configured custom `validate` function? Would that be a meaningful performance boost (if any)? (If we did that, we might also need to add a `capture`d `invalid` event handler to make sure error messages are properly updated if needed.)
  - **Note**: It may be sufficient/appropriate to delegate this to user land. Perhaps we could simply add documentation saying, "For a performance boost, if you don't have any custom `validate` functions, just use `form.checkValidity()`" or something like that. (This, again, is _assuming_ that `form.checkValidity()` yields a significant performance boost over `observer.validateFields()`. We need to test that.) If we go with this approach, we'd probably still need to register `invalid` event handlers. So we need to think about how we'd go about that if we want to go that route.
- [ ] Are there any ways that we can optimize updating the DOM? (For instance, not touching `element.textContent` if the error message didn't change. Is there even a significant performance benefit in doing that?)

### `FormValidityObserver` Potential Future Ideas/Features

- [ ] Provide a way for users to specify the value of `aria-invalid` (e.g., `spelling`). Maybe we could do this through the `ValidationErrors` configuration? (**Note: This idea might not even be significant or truly needed.**)
- [ ] Provide a way for users to focus the first field that errored out.
  - We shouldn't need to provide _access_ to the field that errored out, right? The browser just focuses the first field that errors out on its own. Is it sufficient to copy the browser's behavior there? It makes sense considering that it makes the user aware not only of the current erroneous fields, but _all_ erroneous fields that come after. (It also indicates that no preceding fields are erroneous ... provided that the developer didn't do some weird layout shifting with a flexbox or grid.)
- [ ] Provide an easy way for users to scroll to the field that errored out.
  - Should we support a custom scroller function option for people who need more control over how scrolling happens? Or should we just expose some simple, fixed options for how to scroll. Probably both?
- [ ] Perhaps we should dispatch the `invalid` event when validation fails? Just like the browser does? If we're claiming to _enhance_ the browser's functionality, then we don't really want to _take away_ anything that the browser does. Instead, we want to _add_ to it (as effectively, powerfully, and minimalistically as possible). **Edit**: We won't be supporting this any time soon unless people explicitly request it. See our [Development Notes](./DEVELOPMENT_NOTES.md#why-doesnt-the-formvalidityobserver-dispatch-invalid-events-when-an-accessible-error-gets-displayed)
- [ ] Would it make sense to support default error messages for the various [static] constraints? For instance, oftentimes the same static (but custom) error message is used for required fields. Having configurable default error messages can help save people from duplicating code unnecessarily.
- [ ] Currently, we _technically_ allow developers to do both _accessible_ error messaging and _native_ error messaging simultaneously. It isn't encouraged, but it might be helpful for developers transitioning from one mode to another. Even so, this could be a source of confusion. This already makes our code a little confusing sometimes (potentially) since we effectively determine whether or not a field uses accessible errors based on its `aria-describedby` attribute. If we had an option for the `FormValidityObserver` constructor that let the developer determine whether they were using accessible errors or native errors from the start, that could potentially be more useful/clear... It would at least be more helpful from a maintainability standpoint... well, potentially. Is it worth trying? Or not?

## TypeScript

- The [`@link`](https://jsdoc.app/tags-inline-link.html) JSDoc annotation is _really_ helpful for referencing internal names (e.g., a method/field belonging to the current class in which the comment is scoped). However, it seems to have some limitations in TypeScript. When an `interface` is used to define a name (e.g., `interface FormValidityObserver { /* ... */ }`) _and_ that same name is used as an anonymous class (e.g., `const FormValidityObserver = class { /* ... */ }`), the internal linking works within the anonymous class, but _it breaks inside the `interface`_. (Of the two, this is probably the better way for things to break.) Is this a bug in TypeScript? Should we open an issue? (... Is `implements` the problem? Would `satisfies` fix it?)
  - Similarly, yet separately (and likely in this same scenario), we see that the physical overriden methods within the `FormValidityObserver` are inheriting the wrong JSDoc (AND they don't show the proper JSDocs when hovering over the method parameters). But the JSDocs for methods _are_ correct when the class is physically used/instantiated. Also potentially a bug? Should we open an issue for this?
  - The end-developer's experience isn't really impacted by these problems... so we'll open these issues in the future.

## Testing

- Consider migrating away from `React Testing Library` in all `@form-observer/core` tests. Keyword: **consider**. It might be more work than it's worth, but it would technically embody the idea that the core package should work with pure JS.
